# prewire

This package provides a utility for managing and combining Wire provider sets, specifically designed to handle scenarios
where the same provider function might appear in multiple sets. By using `prewire`, you can define self-contained
`PreWireSet`s in different modules without worrying about duplicate providers causing conflicts when those sets are
combined.

The core idea is to use a pre-processing step that runs **before** `go generate ./...` (which invokes `wire`), allowing
you to statically combine your provider sets and automatically de-duplicate identical provider functions. As the name "
prewire" implies, this tool is intended to be used *prior* to running the official Go Wire tool. You can find more
information about the official Go Wire project here: <https://github.com/google/wire>.

## Usage

The primary way to use this package is via the `prewire` command-line tool.

### 1. Define Your PreWireSet

In your Go package, define a variable named `PreWireSet` of type `prewire.PreWireSet`. This variable will hold the
initial set of providers for that specific package.

```go
package mypackage

import (
	"github.com/cmaher/prewire"
	// Import any packages needed by your providers
)

// PreWireSet defines the initial set of providers for this package.
// The variable name MUST be 'PreWireSet' for the prewire command to find it.
var PreWireSet = prewire.NewSet(
	provider1, // Your provider functions or values
	provider2,
	// ... more providers
)

// Example provider functions (replace with your actual providers)
func provider1() string { return "Provider 1" }
func provider2() int    { return 2 }

```

### 2. Run the `prewire` Command

Navigate to your package directory in the terminal and run the `prewire` command:

```
go run github.com/cmaher/prewire/cmd/prewire
```

This command will analyze your `PreWireSet` variable, resolve any unions, and generate a `prewire_gen.go` file in the
same directory.

The generated `prewire_gen.go` file will contain:

* Necessary import statements based on the packages used by your providers.

* A `go:generate` comment to easily regenerate the file.

* A static `wire.ProviderSet` variable named `WireSet` containing direct references to all unique provider functions and
  values.

```
//go:generate go run github.com/cmaher/prewire/cmd/prewire

package mypackage

import (
	"github.com/google/wire"
	// other/required/imports will be added here based on your providers
)

// WireSet is the statically generated wire.ProviderSet for this package.
// It is generated by the prewire command from the PreWireSet variable.
var WireSet = wire.NewSet(
	provider1,
	provider2,
	// ... all unique providers from this set and any unioned sets
)

```

### 3. Use the Generated `WireSet`

You can now use the generated `WireSet` variable in your `wire.Build` calls, just like any other static
`wire.ProviderSet`.

```
package myinjector

import (
	"github.com/google/wire"
	"mypackage" // Import the package where prewire generated WireSet
	// ... other imports
)

// BuildApp creates your application dependencies using the generated WireSet.
func BuildApp() (App, error) {
	wire.Build(
		mypackage.WireSet, // Use the statically generated set
		// ... other static wire.ProviderSets or providers
	)
	return App{}, nil // Wire will replace this with generated code
}

```

## Including Additional PreWireSets

The power of `prewire` comes from its ability to union `PreWireSet`s from different packages while automatically
handling duplicate providers.

Consider the following structure:

```
/your_module
├── go.mod
├── foo/
│   ├── prewire.go
│   └── providers.go
├── bar/
│   ├── prewire.go
│   └── providers.go
└── baz/
    ├── prewire.go
    └── injector.go
```

**foo/prewire.go:**

```
package foo

import (
	"github.com/cmaher/prewire"
	// Assuming New is defined in foo/providers.go
)

var PreWireSet = prewire.NewSet(New)

```

**bar/prewire.go:**

```
package bar

import (
	"github.com/cmaher/prewire"
	"your_module/foo" // Import the foo package
	// Assuming New is defined in bar/providers.go
)

// This PreWireSet includes its own New provider and unions the set from foo.
var PreWireSet = prewire.NewSet(New).
	Union(foo.PreWireSet)

```

**baz/prewire.go:**

```
package baz

import (
	"github.com/cmaher/prewire"
	"your_module/foo" // Import foo
	"your_module/bar" // Import bar
	// Assuming New is defined in baz/providers.go
)

// This PreWireSet includes its own New provider and unions sets from foo and bar.
// If foo.New, bar.New, and baz.New point to the *exact same function pointer*,
// prewire will ensure it's only included once in the final generated set.
var PreWireSet = prewire.NewSet(New).
	Union(
		foo.PreWireSet,
		bar.PreWireSet, // Note: Corrected typo from original
	)

```

When you run `go generate ./...` (which includes `go run github.com/cmaher/prewire/cmd/prewire` via the `go:generate`
comment) in your module root, or specifically run the `prewire` command in the `baz` directory, it will analyze
`baz/PreWireSet`. It sees that `baz.PreWireSet` unions `foo.PreWireSet` and `bar.PreWireSet`. It will recursively
resolve these unions.

The `prewire` command will collect all providers from `baz/PreWireSet`, `foo/PreWireSet`, and `bar/PreWireSet`. If
`foo.New`, `bar.New`, and `baz.New` point to the exact same underlying function, the `prewire` tool will detect this and
include that function only once in the final generated `baz/prewire_gen.go` file.

The generated `baz/prewire_gen.go` might look something like this (assuming `foo.New`, `bar.New`, and `baz.New` are
distinct functions in this example):

```go
//go:generate go run github.com/cmaher/prewire/cmd/prewire

package baz

import (
	"github.com/google/wire"
	"your_module/foo" // Import required for foo.New
	"your_module/bar" // Import required for bar.New
	// Imports for baz.New will also be included if needed
)

// WireSet is the statically generated wire.ProviderSet for this package.
// It is generated by the prewire command from the PreWireSet variable.
var WireSet = wire.NewSet(
	New,     // Provider from baz/prewire.go
	foo.New, // Provider from foo/prewire.go (via union)
	bar.New, // Provider from bar/prewire.go (via union)
	// ... any other unique providers collected from the unioned sets
)

```

The generated file name `prewire_gen.go` is conventionally processed before `wire_gen.go` by `go generate`, ensuring
that the static `WireSet` is available when `wire` runs.

By using `prewire`, you can compose complex dependency graphs from smaller, reusable, and self-contained `PreWireSet`s
defined across your project, with automatic de-duplication of identical provider functions handled by the pre-generation
step.

## Known Limitations

This package is not particularly robust, and it is built with a very specific usage in mind. It has the following
limitations:

* The variable defining the set MUST be named `PreWireSet`
* Only one PreWireSet is allowed per package
* Variables in the call to Union MUST be named `<package>.PreWireSet`
* This probably does not work with `wire.Bind` or anything else that is not a provider function
* Package names of unioned `PreWireSet`s MUST be either the final name in the package string, or a package alias

I'm not opposed to fixing any of this, but this solves my current problems, and it was also partly an exercise in seeing
how far I could take vibe coding for something technically complicated. 