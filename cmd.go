package prewire

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"maps"
	"os"
	"path/filepath"
	"slices"
	"sort"
	"strings"
	"sync"

	"golang.org/x/tools/go/packages"
)

// Constants for import paths
const (
	PrewireImportPath = "github.com/cmaher/prewire"
	WireImportPath    = "github.com/google/wire"
	GenFile           = "prewire_gen.go"
)

// Constants for wire-related strings
const (
	NewSetStr     = "NewSet"
	UnionStr      = "Union"
	PreWireSetStr = "PreWireSet"
)

type preWireSetData struct {
	packageName string
	preWireSet  *ast.ValueSpec
	expr        ast.Expr
	imports     map[string]string
	fset        *token.FileSet
}

// PrewireCommand is the main entry point for the prewire command
func PrewireCommand() error {
	// We look for the PreWireSet in the current directory
	dir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get current directory: %w", err)
	}

	// Find the PreWireSet variable and collect imports
	preData, err := findPreWireSet(dir)
	if err != nil {
		return err
	}

	// Generate the new file
	outputFile := filepath.Join(dir, GenFile)
	err = generateWireFile(outputFile, preData)
	if err != nil {
		return fmt.Errorf("failed to generate prewire file: %w", err)
	}

	fmt.Printf("Generated prewire file: %s\n", outputFile)
	return nil
}

// findPreWireSetInCurrentPackage finds the PreWireSet variable and collects imports in the current package
func findPreWireSet(pkgDir string) (preWireSetData, error) {
	// Parse the package in the current directory
	fset := token.NewFileSet()
	pkgMap, err := parser.ParseDir(fset, pkgDir, nil, parser.ParseComments)
	if err != nil {
		return preWireSetData{}, fmt.Errorf("failed to parse directory: %w", err)
	}
	pkgs := slices.Collect(maps.Values(pkgMap))
	if len(pkgs) != 1 {
		return preWireSetData{}, fmt.Errorf("should have found 1 and only one package, but found %v", pkgs)
	}
	pkg := pkgs[0]

	// Find the PreWireSet variable and collect imports
	var preWireSet *ast.ValueSpec
	var preWireSetExpr ast.Expr
	var preWireSetFile *ast.File

	// Find the PreWireSet variable
	for _, file := range pkg.Files {
		ast.Inspect(file, func(n ast.Node) bool {
			if decl, ok := n.(*ast.GenDecl); ok && decl.Tok == token.VAR {
				for _, spec := range decl.Specs {
					if valueSpec, ok := spec.(*ast.ValueSpec); ok {
						for i, name := range valueSpec.Names {
							if name.Name == PreWireSetStr {
								preWireSet = valueSpec
								preWireSetFile = file
								if i < len(valueSpec.Values) {
									preWireSetExpr = valueSpec.Values[i]
								}
								return false
							}
						}
					}
				}
			}
			return true
		})

		if preWireSet != nil {
			break
		}
	}

	if preWireSet == nil {
		return preWireSetData{}, fmt.Errorf("%s variable not found in package %s", PreWireSetStr, pkg.Name)
	}

	// Collect imports
	imports := make(map[string]string) // Import path -> alias
	for _, imp := range preWireSetFile.Imports {
		path := strings.Trim(imp.Path.Value, "\"")
		var alias string
		if imp.Name != nil {
			alias = imp.Name.Name
		} else {
			// Extract the package name from the import path
			parts := strings.Split(path, "/")
			alias = parts[len(parts)-1]
		}
		imports[path] = alias
	}

	return preWireSetData{
		pkg.Name,
		preWireSet,
		preWireSetExpr,
		imports,
		fset,
	}, nil
}

// generateWireFile generates a new Go file with a static representation of the wire set
func generateWireFile(outputFile string, preData preWireSetData) error {
	// Extract provider functions and import paths from the PreWireSet expression
	providerFuncs, importPaths, err := extractProviderFunctions(preData, preData.fset)
	if err != nil {
		return fmt.Errorf("failed to extract provider functions: %w", err)
	}

	// Deduplicate provider functions
	providerFuncsMap := make(map[string]bool)
	var uniqueProviderFuncs []string
	for _, providerFunc := range providerFuncs {
		if !providerFuncsMap[providerFunc] {
			providerFuncsMap[providerFunc] = true
			uniqueProviderFuncs = append(uniqueProviderFuncs, providerFunc)
		}
	}
	providerFuncs = uniqueProviderFuncs

	// Start building the file content
	var content strings.Builder

	// Add generated file comment
	content.WriteString("// Code generated by prewire; DO NOT EDIT.\n")

	// Add go:generate comment
	genStr := fmt.Sprintf("//go:generate go run %s/cmd/prewire\n\n", PrewireImportPath)
	content.WriteString(genStr)

	// Add package declaration
	content.WriteString(fmt.Sprintf("package %s\n\n", preData.packageName))

	writeImports(&content, importPaths, providerFuncs, preData)

	// Add WireSet variable
	content.WriteString("// WireSet is the provider set for this package\n")
	content.WriteString("var WireSet = wire.NewSet(\n")

	// Add provider functions
	for _, providerFunc := range providerFuncs {
		content.WriteString(fmt.Sprintf("\t%s,\n", providerFunc))
	}

	content.WriteString(")\n")

	// Write the file
	return os.WriteFile(outputFile, []byte(content.String()), 0644)
}

func writeImports(content *strings.Builder, importPaths []string, providerFuncs []string, preData preWireSetData) {
	// Add imports
	content.WriteString("import (\n")
	// Add github.com/google/wire
	content.WriteString(fmt.Sprintf("\t\"%s\"\n", WireImportPath))

	// Only include necessary imports
	allImports := make(map[string]bool)
	allImports[WireImportPath] = true

	// Add imports from unionized sets
	for _, path := range importPaths {
		allImports[path] = true
	}

	// Track which packages are used by provider functions
	usedPackages := make(map[string]bool)
	for _, providerFunc := range providerFuncs {
		// Check if the provider function has a package prefix
		if strings.Contains(providerFunc, ".") {
			parts := strings.SplitN(providerFunc, ".", 2)
			usedPackages[parts[0]] = true
		}
	}

	// Create a map of package name to import path
	packageToImport := make(map[string]string)
	for path, alias := range preData.imports {
		packageToImport[alias] = path
	}

	// Only include imports for packages that are actually used in provider functions
	for pkg := range usedPackages {
		if path, ok := packageToImport[pkg]; ok {
			allImports[path] = true
		}
	}

	// Get all import paths except wire and prewire
	var trimmedImportPaths []string
	for path := range allImports {
		if path != WireImportPath && path != PrewireImportPath {
			trimmedImportPaths = append(trimmedImportPaths, path)
		}
	}

	// Sort import paths alphabetically
	sort.Strings(trimmedImportPaths)

	// Write all imports in alphabetical order
	for _, path := range trimmedImportPaths {
		alias := preData.imports[path]
		// Check if the alias is different from the last part of the path
		parts := strings.Split(path, "/")
		defaultAlias := parts[len(parts)-1]

		if alias != defaultAlias {
			// If there's a custom alias, include it in the import
			content.WriteString(fmt.Sprintf("\t%s \"%s\"\n", alias, path))
		} else {
			// Otherwise, just write the import path
			content.WriteString(fmt.Sprintf("\t\"%s\"\n", path))
		}
	}

	content.WriteString(")\n\n")
}

// extractProviderFunctions extracts provider functions from a PreWireSet expression
func extractProviderFunctions(preData preWireSetData, fset *token.FileSet) ([]string, []string, error) {
	var providerFuncs []string
	var importPaths []string

	// Process the expression based on its type
	switch e := preData.expr.(type) {
	case *ast.CallExpr:
		// Check if it's a prewire.NewSet call
		if sel, ok := e.Fun.(*ast.SelectorExpr); ok && sel.Sel.Name == NewSetStr {
			// Process each argument to NewSet
			for _, arg := range e.Args {
				var providerStr strings.Builder
				printer.Fprint(&providerStr, fset, arg)
				providerFuncs = append(providerFuncs, providerStr.String())
			}
		}

	case *ast.SelectorExpr:
		// It's a selector expression, but we don't need to process it further
		return providerFuncs, importPaths, nil

	case *ast.Ident:
		// It's an identifier, but we don't need to process it further
		return providerFuncs, importPaths, nil
	}

	// Check if there's a Union call
	if callExpr, ok := preData.expr.(*ast.CallExpr); ok {
		if selExpr, ok := callExpr.Fun.(*ast.SelectorExpr); ok && selExpr.Sel.Name == UnionStr {
			// Process the receiver of the Union call
			recieverPreData := preData
			recieverPreData.expr = selExpr.X
			receiverFuncs, receiverImports, err := extractProviderFunctions(recieverPreData, fset)
			if err != nil {
				return nil, nil, err
			}
			providerFuncs = append(providerFuncs, receiverFuncs...)
			importPaths = append(importPaths, receiverImports...)

			// Process each argument to Union
			for _, arg := range callExpr.Args {
				if sel, ok := arg.(*ast.SelectorExpr); ok {
					// This is a reference to a PreWireSet in another package
					if strings.HasSuffix(sel.Sel.Name, PreWireSetStr) {
						// Extract the package name from the selector
						var pkgName string
						ident, ok := sel.X.(*ast.Ident)
						if !ok {
							return nil, nil, fmt.Errorf("failed to extract package name from %s", sel.Sel.Name)
						}
						pkgName = ident.Name

						// Find the import path for this package by looking at the imports in the current file
						var importPath string
						for path, name := range preData.imports {
							if name == pkgName {
								importPath = path
								break
							}
						}
						if importPath == "" {
							return nil, nil, fmt.Errorf("failed to resolve import path for %s", pkgName)
						}
						importPaths = append(importPaths, importPath)

						// Find the package directory based on the import path
						pkgDir, updatedImportPath, err := findPackageDir(importPath)
						if err != nil {
							return nil, nil, err
						}

						// Update the import path if it changed
						if updatedImportPath != importPath {
							importPaths[len(importPaths)-1] = updatedImportPath
							importPath = updatedImportPath
						}

						// Find the PreWireSet expression in the package
						newPreData, err := findPreWireSet(pkgDir)
						if err != nil {
							return nil, nil, err
						}

						// Create a new file set for parsing
						newFset := token.NewFileSet()
						// Extract provider functions from the PreWireSet
						pkgProviderFuncs, pkgImportPaths, err := extractProviderFunctions(newPreData, newFset)
						if err != nil {
							return nil, nil, fmt.Errorf("failed to extract provider functions from package %s: %w", pkgName, err)
						}

						// Add the package name prefix to each provider function
						for i, providerFunc := range pkgProviderFuncs {
							// If the provider function already has a package prefix, keep it
							if !strings.Contains(providerFunc, ".") {
								pkgProviderFuncs[i] = pkgName + "." + providerFunc
							}
						}

						addUnionedImports(&preData, newPreData)

						providerFuncs = append(providerFuncs, pkgProviderFuncs...)
						importPaths = append(importPaths, pkgImportPaths...)
					}
				} else if _, ok := arg.(*ast.Ident); ok {
					return nil, nil, fmt.Errorf("only one PreWireSet is allowed per package")
				}
			}
		}
	}

	return providerFuncs, importPaths, nil
}

func addUnionedImports(preData *preWireSetData, newPreData preWireSetData) {
	// Also add any aliased imports from the unionized package to the parent package's imports
	for path, alias := range newPreData.imports {
		if path != PrewireImportPath && path != WireImportPath {
			// If this is an aliased import, add the alias to the parent package's imports
			parts := strings.Split(path, "/")
			defaultAlias := parts[len(parts)-1]
			if alias != defaultAlias {
				// Add the alias to the parent package's imports
				preData.imports[path] = alias
			}
		}
	}
}

// Cache for package directory lookups
var packageDirCache = make(map[string]string)
var packageDirCacheMutex sync.RWMutex

// resolvePackage resolves a package path to its directory using go/packages API
func resolvePackage(importPath string) (string, error) {
	cfg := &packages.Config{
		Mode: packages.NeedFiles,
		Dir:  ".", // Current directory
	}

	pkgs, err := packages.Load(cfg, importPath)
	if err != nil {
		return "", fmt.Errorf("failed to load package %s: %w", importPath, err)
	}

	if len(pkgs) == 0 {
		return "", fmt.Errorf("package %s not found", importPath)
	}

	if len(pkgs[0].GoFiles) == 0 {
		return "", fmt.Errorf("package %s has no Go files", importPath)
	}

	// Return the directory of the first Go file
	return filepath.Dir(pkgs[0].GoFiles[0]), nil
}

// resolvePackageWithCache resolves a package path with caching for performance
func resolvePackageWithCache(importPath string) (string, error) {
	// Check cache first
	packageDirCacheMutex.RLock()
	if dir, ok := packageDirCache[importPath]; ok {
		packageDirCacheMutex.RUnlock()
		return dir, nil
	}
	packageDirCacheMutex.RUnlock()

	// Not in cache, resolve it
	dir, err := resolvePackage(importPath)
	if err != nil {
		return "", err
	}

	// Add to cache
	packageDirCacheMutex.Lock()
	packageDirCache[importPath] = dir
	packageDirCacheMutex.Unlock()

	return dir, nil
}

// findPackageDir finds the package directory based on the import path
func findPackageDir(importPath string) (string, string, error) {
	// Use go/packages to resolve the package
	dir, err := resolvePackageWithCache(importPath)
	if err != nil {
		return "", "", fmt.Errorf("failed to resolve package %s: %w", importPath, err)
	}

	// Successfully resolved the package
	return dir, importPath, nil
}
